{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home The goal of this project is to collect nice coding problems. Articles Palindromic substrings Producers and consumers Count Subarrays With Score Less Than K Zero path Robots in skyscraper Candy sticks Changelog Changelog","title":"Home"},{"location":"#home","text":"The goal of this project is to collect nice coding problems.","title":"Home"},{"location":"#articles","text":"Palindromic substrings Producers and consumers Count Subarrays With Score Less Than K Zero path Robots in skyscraper Candy sticks","title":"Articles"},{"location":"#changelog","text":"Changelog","title":"Changelog"},{"location":"candy_sticks/","text":"Candy sticks Description There are \\(M\\) kids and \\(N\\) candy sticks. Kids will be happy only if every kid receives candy stick of the same length. Candy sticks can be split, but it's not possible to stick them together. The task is to find the maximum length of the candy stick and make kids happy. Input data The first line contains \\(N\\) - number of candy sticks, \\(M\\) - number of kids. Second line contains \\(N\\) integers - \\(a_{i}\\) length of the \\(i_{th}\\) candy stick. Output data Maximum length of the candy stick with error that doesn't exceed \\(10^{-4}\\) . Constraints 1 \\(\\leqslant\\) N, M \\(\\leqslant\\) \\(1000\\) , 0 \\(\\leqslant\\) \\(a_{i}\\) \\(\\leqslant\\) \\(10^9\\) Example test cases Input : 3 4 1 10 5 Output : 3.333333 Input : 3 5 1 1 1 Output : 0.500000 Solution Solution is to run the binary search for the length of the candy stick. At first, find the boundaries for the binary search lines [6-19]. If the number of sticks is more than number of kids then the shortest stick length is the left boundary else 0. Search invariant: for each length \\(m\\) check the amount sticks that is possible to obtain by splits [25-28]. If the amount of sticks is more or equal to kids number, then update the left boundary, right otherwise. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int main () { int N , M ; cin >> N >> M ; vector < double > v ( N , 0 ); double l = INT_MAX ; double r = INT_MIN ; for ( int i = 0 ; i < N ; ++ i ) { cin >> v [ i ]; l = std :: min ( l , v [ i ]); r = std :: max ( r , v [ i ]); } if ( M > N ) { l = 0 ; } while ( r - l > 0.0000001 ) { double m = l + ( r - l ) / 2 ; int count = 0 ; for ( const auto a : v ) { count += a / m ; } if ( count >= M ) { l = m ; } else { r = m ; } } printf ( \"%.7lf\" , l ); return 0 ; } Solution time complexity: \\(O(N*log(max(a_{i})))\\) Solution memory complexity: \\(O(N)\\) References 0023 on algotester","title":"Candy sticks"},{"location":"candy_sticks/#candy-sticks","text":"","title":"Candy sticks"},{"location":"candy_sticks/#description","text":"There are \\(M\\) kids and \\(N\\) candy sticks. Kids will be happy only if every kid receives candy stick of the same length. Candy sticks can be split, but it's not possible to stick them together. The task is to find the maximum length of the candy stick and make kids happy.","title":"Description"},{"location":"candy_sticks/#input-data","text":"The first line contains \\(N\\) - number of candy sticks, \\(M\\) - number of kids. Second line contains \\(N\\) integers - \\(a_{i}\\) length of the \\(i_{th}\\) candy stick.","title":"Input data"},{"location":"candy_sticks/#output-data","text":"Maximum length of the candy stick with error that doesn't exceed \\(10^{-4}\\) .","title":"Output data"},{"location":"candy_sticks/#constraints","text":"1 \\(\\leqslant\\) N, M \\(\\leqslant\\) \\(1000\\) , 0 \\(\\leqslant\\) \\(a_{i}\\) \\(\\leqslant\\) \\(10^9\\)","title":"Constraints"},{"location":"candy_sticks/#example-test-cases","text":"Input : 3 4 1 10 5 Output : 3.333333 Input : 3 5 1 1 1 Output : 0.500000","title":"Example test cases"},{"location":"candy_sticks/#solution","text":"Solution is to run the binary search for the length of the candy stick. At first, find the boundaries for the binary search lines [6-19]. If the number of sticks is more than number of kids then the shortest stick length is the left boundary else 0. Search invariant: for each length \\(m\\) check the amount sticks that is possible to obtain by splits [25-28]. If the amount of sticks is more or equal to kids number, then update the left boundary, right otherwise. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int main () { int N , M ; cin >> N >> M ; vector < double > v ( N , 0 ); double l = INT_MAX ; double r = INT_MIN ; for ( int i = 0 ; i < N ; ++ i ) { cin >> v [ i ]; l = std :: min ( l , v [ i ]); r = std :: max ( r , v [ i ]); } if ( M > N ) { l = 0 ; } while ( r - l > 0.0000001 ) { double m = l + ( r - l ) / 2 ; int count = 0 ; for ( const auto a : v ) { count += a / m ; } if ( count >= M ) { l = m ; } else { r = m ; } } printf ( \"%.7lf\" , l ); return 0 ; } Solution time complexity: \\(O(N*log(max(a_{i})))\\) Solution memory complexity: \\(O(N)\\)","title":"Solution"},{"location":"candy_sticks/#references","text":"0023 on algotester","title":"References"},{"location":"changelog/","text":"Changelog 0.1.5 _ July 16, 2022 Add Candy sticks 0.1.4 _ July 3, 2022 Add Robots in skyscraper 0.1.3 _ June 19, 2022 Add Zero path 0.1.2 _ June 12, 2022 Add Count Subarrays With Score Less Than K 0.1.1 _ May 24, 2022 Add producers and consumers 0.1.0 _ May 24, 2022 Initial release","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#0.1.5","text":"Add Candy sticks","title":"0.1.5 _ July 16, 2022"},{"location":"changelog/#0.1.4","text":"Add Robots in skyscraper","title":"0.1.4 _ July 3, 2022"},{"location":"changelog/#0.1.3","text":"Add Zero path","title":"0.1.3 _ June 19, 2022"},{"location":"changelog/#0.1.2","text":"Add Count Subarrays With Score Less Than K","title":"0.1.2 _ June 12, 2022"},{"location":"changelog/#0.1.1","text":"Add producers and consumers","title":"0.1.1 _ May 24, 2022"},{"location":"changelog/#0.1.0","text":"Initial release","title":"0.1.0 _ May 24, 2022"},{"location":"count_subarrays_with_score_less_than_K/","text":"Problem statement The score of an array is defined as the product of its sum and its length. For example, the score of [1, 2, 3, 4, 5] is (1 + 2 + 3 + 4 + 5) * 5 = 75 . Given a positive integer array nums and an integer \\(K\\) , return the number of non-empty \\(subarrays\\) of nums whose score is strictly less than \\(K\\) . A \\(subarray\\) is a contiguous sequence of elements within an array. Example test cases Example #1 Input : nums = [ 2 , 1 , 4 , 3 , 5 ], k = 10 Output : 6 Explanation : The 6 subarrays having scores less than 10 are : - [ 2 ] with score 2 * 1 = 2. - [ 1 ] with score 1 * 1 = 1. - [ 4 ] with score 4 * 1 = 4. - [ 3 ] with score 3 * 1 = 3. - [ 5 ] with score 5 * 1 = 5. - [ 2 , 1 ] with score ( 2 + 1 ) * 2 = 6. Note that subarrays such as [ 1 , 4 ] and [ 4 , 3 , 5 ] are not considered because their scores are 10 and 36 respectively , while we need scores strictly less than 10. Example #2 Input : nums = [ 1 , 1 , 1 ], k = 5 Output : 5 Explanation : Every subarray except [ 1 , 1 , 1 ] has a score less than 5. [ 1 , 1 , 1 ] has a score ( 1 + 1 + 1 ) * 3 = 9 , which is greater than 5. Thus , there are 5 subarrays having scores less than 5. Constraints 1 <= nums . length <= 105 1 <= nums [ i ] <= 105 1 <= k <= 1015 Observation If there is an array with length \\(L\\) and \\(score < K\\) , then it produces \\(S = 1 + 2 + 3 + ... + L\\) different subarrays. Solution: prefix sum + binary search Create the prefix sum array [6-10]; For each \\(i_{th}\\) find the longest subarray with \\(score < K\\) [15-31]; Calculate and add \\(S\\) to the result [33]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : long long countSubarrays ( vector < int >& nums , long long k ) { const auto N = nums . size (); vector < long long > prefix ( N , 0 ); prefix [ 0 ] = nums [ 0 ]; for ( int i = 1 ; i < N ; ++ i ) prefix [ i ] += nums [ i ] + prefix [ i -1 ]; long long res = 0 ; for ( int s = 0 ; s < N ; ++ s ) { int l = s ; int r = N ; while ( l < r ) { int m = l + ( r - l ) / 2 ; long long sum = prefix [ m ] - ( s > 0 ? prefix [ s -1 ] : 0 ); long long v = sum * ( m - s + 1 ); if ( v < k ) { l = m + 1 ; } else { r = m ; } } res += l - s ; } return res ; } }; Solution time complexity: \\(O(n*log(n))\\) Solution memory complexity: \\(O(n)\\) Solution: sliding window On each iteration extend the sliding window to the right and calculate the new sum; If \\(score\\) \\(\\geqslant\\) \\(K\\) , then shrink window by popping out the element from the left until \\(score < K\\) ; Calculate and add \\(S\\) to the result. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : long long countSubarrays ( vector < int >& nums , long long k ) { long long sum = 0 , ans = 0 ; for ( int e = 0 , s = 0 ; e < nums . size (); ++ e ) { sum += nums [ e ]; while ( sum * ( e - s + 1 ) >= k ) { sum -= nums [ s ++ ]; } ans += e - s + 1 ; } return ans ; } }; Solution time complexity: \\(O(n)\\) Solution memory complexity: \\(O(1)\\) References Count Subarrays With Score Less Than K on leetcode","title":"Count Subarrays With Score Less Than K"},{"location":"count_subarrays_with_score_less_than_K/#problem-statement","text":"The score of an array is defined as the product of its sum and its length. For example, the score of [1, 2, 3, 4, 5] is (1 + 2 + 3 + 4 + 5) * 5 = 75 . Given a positive integer array nums and an integer \\(K\\) , return the number of non-empty \\(subarrays\\) of nums whose score is strictly less than \\(K\\) . A \\(subarray\\) is a contiguous sequence of elements within an array.","title":"Problem statement"},{"location":"count_subarrays_with_score_less_than_K/#example-test-cases","text":"","title":"Example test cases"},{"location":"count_subarrays_with_score_less_than_K/#example-1","text":"Input : nums = [ 2 , 1 , 4 , 3 , 5 ], k = 10 Output : 6 Explanation : The 6 subarrays having scores less than 10 are : - [ 2 ] with score 2 * 1 = 2. - [ 1 ] with score 1 * 1 = 1. - [ 4 ] with score 4 * 1 = 4. - [ 3 ] with score 3 * 1 = 3. - [ 5 ] with score 5 * 1 = 5. - [ 2 , 1 ] with score ( 2 + 1 ) * 2 = 6. Note that subarrays such as [ 1 , 4 ] and [ 4 , 3 , 5 ] are not considered because their scores are 10 and 36 respectively , while we need scores strictly less than 10.","title":"Example #1"},{"location":"count_subarrays_with_score_less_than_K/#example-2","text":"Input : nums = [ 1 , 1 , 1 ], k = 5 Output : 5 Explanation : Every subarray except [ 1 , 1 , 1 ] has a score less than 5. [ 1 , 1 , 1 ] has a score ( 1 + 1 + 1 ) * 3 = 9 , which is greater than 5. Thus , there are 5 subarrays having scores less than 5.","title":"Example #2"},{"location":"count_subarrays_with_score_less_than_K/#constraints","text":"1 <= nums . length <= 105 1 <= nums [ i ] <= 105 1 <= k <= 1015","title":"Constraints"},{"location":"count_subarrays_with_score_less_than_K/#observation","text":"If there is an array with length \\(L\\) and \\(score < K\\) , then it produces \\(S = 1 + 2 + 3 + ... + L\\) different subarrays.","title":"Observation"},{"location":"count_subarrays_with_score_less_than_K/#solution-prefix-sum-binary-search","text":"Create the prefix sum array [6-10]; For each \\(i_{th}\\) find the longest subarray with \\(score < K\\) [15-31]; Calculate and add \\(S\\) to the result [33]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : long long countSubarrays ( vector < int >& nums , long long k ) { const auto N = nums . size (); vector < long long > prefix ( N , 0 ); prefix [ 0 ] = nums [ 0 ]; for ( int i = 1 ; i < N ; ++ i ) prefix [ i ] += nums [ i ] + prefix [ i -1 ]; long long res = 0 ; for ( int s = 0 ; s < N ; ++ s ) { int l = s ; int r = N ; while ( l < r ) { int m = l + ( r - l ) / 2 ; long long sum = prefix [ m ] - ( s > 0 ? prefix [ s -1 ] : 0 ); long long v = sum * ( m - s + 1 ); if ( v < k ) { l = m + 1 ; } else { r = m ; } } res += l - s ; } return res ; } }; Solution time complexity: \\(O(n*log(n))\\) Solution memory complexity: \\(O(n)\\)","title":"Solution: prefix sum + binary search"},{"location":"count_subarrays_with_score_less_than_K/#solution-sliding-window","text":"On each iteration extend the sliding window to the right and calculate the new sum; If \\(score\\) \\(\\geqslant\\) \\(K\\) , then shrink window by popping out the element from the left until \\(score < K\\) ; Calculate and add \\(S\\) to the result. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : long long countSubarrays ( vector < int >& nums , long long k ) { long long sum = 0 , ans = 0 ; for ( int e = 0 , s = 0 ; e < nums . size (); ++ e ) { sum += nums [ e ]; while ( sum * ( e - s + 1 ) >= k ) { sum -= nums [ s ++ ]; } ans += e - s + 1 ; } return ans ; } }; Solution time complexity: \\(O(n)\\) Solution memory complexity: \\(O(1)\\)","title":"Solution: sliding window"},{"location":"count_subarrays_with_score_less_than_K/#references","text":"Count Subarrays With Score Less Than K on leetcode","title":"References"},{"location":"palindromic_substrings/","text":"Problem statement Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string. Example test cases Input : s = \"abc\" Output : 3 Explanation : Three palindromic strings : \"a\" , \"b\" , \"c\" . Input : s = \"aaa\" Output : 6 Explanation : Six palindromic strings : \"a\" , \"a\" , \"a\" , \"aa\" , \"aa\" , \"aaa\" . Constraints 1 <= s . length <= 1000 s consists of lowercase English letters . Brute force solution The idea is to take all possible substrings \\([i, j]\\) and check whether it's a palindrome: class Solution { public : .... int countSubstrings ( string s ) { int res = s . size (); for ( int len = 2 ; len <= s . size (); ++ len ) { for ( int i = 0 ; i + len - 1 < s . size (); ++ i ) { res += isPalindrome ( s , i , len ); } } return res ; } }; isPalindrome itself can be either recursive or iterative: Recursive: bool isPalindrome ( const string & s , int i , int len ) { if ( len == 1 ){ return true ; } const bool firstLastMatch = s [ i ] == s [ i + len -1 ]; if ( len == 2 ) { return firstLastMatch ; } return firstLastMatch && isPalindrome ( s , i + 1 , len - 2 ); } Iterative: bool isPalindrome ( const string & s , int i , int len ) { for ( int l = i , r = i + len - 1 ; l < r ; ++ l , -- r ) { if ( s [ l ] != s [ r ]) { return false ; } } return true ; } Solution time complexity: \\(O(n^3)\\) Solution memory complexity: \\(O(n)\\) Top down approach (memoization) The idea is to reuse previous isPalindrome results, so: \\[isPalindrome(s, i, len) = \\begin{cases} true, &\\text{for } len=1 \\\\ s[i] == s[i+1], &\\text{for }\\text len=2 \\\\ isPalindrome(s, i+1, len - 2),&\\text{for }\\text len>2 \\\\ \\end{cases}\\] class Solution { public : bool isPalindrome ( const string & s , int i , int len ) { if ( len <= 1 ) { return true ; } if ( len == 2 ) { return s [ i ] == s [ i + 1 ]; } const auto key = static_cast < uint64_t > ( i ) << 32 | len ; if ( auto it = cache . find ( key ); it != cache . end ()) { return it -> second ; } const bool res = s [ i ] == s [ i + len - 1 ] && isPalindrome ( s , i + 1 , len - 2 ); cache [ key ] = res ; return res ; } int countSubstrings ( string s ) { int res = s . size (); for ( int len = 2 ; len <= s . size (); ++ len ) { for ( int i = 0 ; i + len - 1 < s . size (); ++ i ) { res += isPalindrome ( s , i , len ); } } return res ; } unordered_map < uint64_t , bool > cache ; }; Solution time complexity: \\(O(n^2)\\) Solution memory complexity: \\(O(n^2)\\) Dynamic programming approach Memoization makes a lot of memory allocations and lookups in the hash table. All these together can be avoided using dynamic programming (bottom-up approach). class Solution { public : int countSubstrings ( string s ) { const auto N = s . size (); vector < vector < bool >> dp ( N , vector < bool > ( N + 1 , false )); for ( int i = 0 ; i < N ; ++ i ) { dp [ i ][ 1 ] = true ; } int ans = N ; for ( int i = 0 ; i + 1 < N ; ++ i ) { dp [ i ][ 2 ] = s [ i ] == s [ i + 1 ]; ans += dp [ i ][ 2 ]; } for ( int len = 3 ; len <= N ; ++ len ) { for ( int i = 0 ; i + len - 1 < N ; ++ i ) { if ( s [ i ] == s [ i + len - 1 ]) { dp [ i ][ len ] = dp [ i + 1 ][ len - 2 ]; ans += dp [ i ][ len ]; } } } return ans ; } }; Solution time complexity: \\(O(n^2)\\) Solution memory complexity: \\(O(n^2)\\) Performance testing results The same test cases were run on leetcode and below are approximate numbers. Implementation Tests execution duration, ms Brute force + isPalindrome (recursive) 300 Brute force + isPalindrome 200 Memoization 500 Dynamic programming 40 References Palindromic substrings problem on leetcode","title":"Palindromic substrings"},{"location":"palindromic_substrings/#problem-statement","text":"Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string.","title":"Problem statement"},{"location":"palindromic_substrings/#example-test-cases","text":"Input : s = \"abc\" Output : 3 Explanation : Three palindromic strings : \"a\" , \"b\" , \"c\" . Input : s = \"aaa\" Output : 6 Explanation : Six palindromic strings : \"a\" , \"a\" , \"a\" , \"aa\" , \"aa\" , \"aaa\" .","title":"Example test cases"},{"location":"palindromic_substrings/#constraints","text":"1 <= s . length <= 1000 s consists of lowercase English letters .","title":"Constraints"},{"location":"palindromic_substrings/#brute-force-solution","text":"The idea is to take all possible substrings \\([i, j]\\) and check whether it's a palindrome: class Solution { public : .... int countSubstrings ( string s ) { int res = s . size (); for ( int len = 2 ; len <= s . size (); ++ len ) { for ( int i = 0 ; i + len - 1 < s . size (); ++ i ) { res += isPalindrome ( s , i , len ); } } return res ; } }; isPalindrome itself can be either recursive or iterative: Recursive: bool isPalindrome ( const string & s , int i , int len ) { if ( len == 1 ){ return true ; } const bool firstLastMatch = s [ i ] == s [ i + len -1 ]; if ( len == 2 ) { return firstLastMatch ; } return firstLastMatch && isPalindrome ( s , i + 1 , len - 2 ); } Iterative: bool isPalindrome ( const string & s , int i , int len ) { for ( int l = i , r = i + len - 1 ; l < r ; ++ l , -- r ) { if ( s [ l ] != s [ r ]) { return false ; } } return true ; } Solution time complexity: \\(O(n^3)\\) Solution memory complexity: \\(O(n)\\)","title":"Brute force solution"},{"location":"palindromic_substrings/#top-down-approach-memoization","text":"The idea is to reuse previous isPalindrome results, so: \\[isPalindrome(s, i, len) = \\begin{cases} true, &\\text{for } len=1 \\\\ s[i] == s[i+1], &\\text{for }\\text len=2 \\\\ isPalindrome(s, i+1, len - 2),&\\text{for }\\text len>2 \\\\ \\end{cases}\\] class Solution { public : bool isPalindrome ( const string & s , int i , int len ) { if ( len <= 1 ) { return true ; } if ( len == 2 ) { return s [ i ] == s [ i + 1 ]; } const auto key = static_cast < uint64_t > ( i ) << 32 | len ; if ( auto it = cache . find ( key ); it != cache . end ()) { return it -> second ; } const bool res = s [ i ] == s [ i + len - 1 ] && isPalindrome ( s , i + 1 , len - 2 ); cache [ key ] = res ; return res ; } int countSubstrings ( string s ) { int res = s . size (); for ( int len = 2 ; len <= s . size (); ++ len ) { for ( int i = 0 ; i + len - 1 < s . size (); ++ i ) { res += isPalindrome ( s , i , len ); } } return res ; } unordered_map < uint64_t , bool > cache ; }; Solution time complexity: \\(O(n^2)\\) Solution memory complexity: \\(O(n^2)\\)","title":"Top down approach (memoization)"},{"location":"palindromic_substrings/#dynamic-programming-approach","text":"Memoization makes a lot of memory allocations and lookups in the hash table. All these together can be avoided using dynamic programming (bottom-up approach). class Solution { public : int countSubstrings ( string s ) { const auto N = s . size (); vector < vector < bool >> dp ( N , vector < bool > ( N + 1 , false )); for ( int i = 0 ; i < N ; ++ i ) { dp [ i ][ 1 ] = true ; } int ans = N ; for ( int i = 0 ; i + 1 < N ; ++ i ) { dp [ i ][ 2 ] = s [ i ] == s [ i + 1 ]; ans += dp [ i ][ 2 ]; } for ( int len = 3 ; len <= N ; ++ len ) { for ( int i = 0 ; i + len - 1 < N ; ++ i ) { if ( s [ i ] == s [ i + len - 1 ]) { dp [ i ][ len ] = dp [ i + 1 ][ len - 2 ]; ans += dp [ i ][ len ]; } } } return ans ; } }; Solution time complexity: \\(O(n^2)\\) Solution memory complexity: \\(O(n^2)\\)","title":"Dynamic programming approach"},{"location":"palindromic_substrings/#performance-testing-results","text":"The same test cases were run on leetcode and below are approximate numbers. Implementation Tests execution duration, ms Brute force + isPalindrome (recursive) 300 Brute force + isPalindrome 200 Memoization 500 Dynamic programming 40","title":"Performance testing results"},{"location":"palindromic_substrings/#references","text":"Palindromic substrings problem on leetcode","title":"References"},{"location":"producers_consumers/","text":"Producers and consumers problem Description There are multiple producers and consumers. Each producer can push item to the queue until queue size limit is reached. Each consumer can pop item from the queue until queue is empty. Accessing queue is not allowed simultaneously: only one producer/consumer can push/pop item at a time. Solution using mutex For each push/pop from the queue, lock mutex for exclusive access: void produce_mutex ( std :: queue < int > & q ) { while ( counter < target ) { if ( q . size () < queue_size_limit ) { std :: lock_guard < std :: mutex > lock ( m ); if ( q . size () < queue_size_limit ) { q . push ( random ()); } } } } void consume_mutex ( std :: queue < int > & q ) { while ( counter < target ) { if ( ! q . empty ()) { std :: lock_guard < std :: mutex > lock ( m ); if ( ! q . empty ()) { q . pop (); counter ++ ; } } } } Downside is the huge amount of context switches. Solution using condition variable Do push/pop iterations in a loop while is possible. Afterwards notify and unblock other threads. void produce_cv ( std :: queue < int > & q ) { std :: unique_lock lk ( m ); while ( counter < target ) { cv . wait ( lk , [ & q ]() { return q . size () < queue_size_limit ; }); q . push ( random ()); cv . notify_all (); } } void consume_cv ( std :: queue < int > & q ) { std :: unique_lock lk ( m ); while ( counter < target ) { cv . wait ( lk , [ & q ]() { return ! q . empty (); }); q . pop (); counter ++ ; cv . notify_all (); } } Testing results: Running test #1 Mutex : workers amount = 8 , elapsed time = 1260 ms Conditional variable: workers amount = 8 , elapsed time = 435 ms Running test #2 Mutex : workers amount = 8 , elapsed time = 1281 ms Conditional variable: workers amount = 8 , elapsed time = 384 ms Running test #3 Mutex : workers amount = 8 , elapsed time = 1298 ms Conditional variable: workers amount = 8 , elapsed time = 391 ms Running test #4 Mutex : workers amount = 8 , elapsed time = 1321 ms Conditional variable: workers amount = 8 , elapsed time = 397 ms Running test #5 Mutex : workers amount = 8 , elapsed time = 1339 ms Conditional variable: workers amount = 8 , elapsed time = 440 ms Implementation using condition variable gives x3 speed-up due to less amount of context switches. Full source code listing: #include <atomic> #include <chrono> #include <condition_variable> #include <functional> #include <iostream> #include <mutex> #include <queue> #include <ratio> #include <string> #include <thread> class Solution ; typedef void ( Solution ::* ConsumerMemFn )( std :: queue < int > & q ); typedef void ( Solution ::* ProducerMemFn )( std :: queue < int > & q ); class Solution { public : void run () { for ( int t = 0 ; t < 5 ; ++ t ) { printf ( \"Running test #%d \\n \" , t + 1 ); run_test ( \"Mutex \" , & Solution :: produce_mutex , & Solution :: consume_mutex ); run_test ( \"Conditional variable\" , & Solution :: produce_cv , & Solution :: consume_cv ); } } void run_test ( std :: string testName , ProducerMemFn producer , ConsumerMemFn consumer ) { const std :: size_t N = std :: max ( std :: thread :: hardware_concurrency (), 2u ); std :: queue < int > q ; counter = 0 ; auto start = std :: chrono :: high_resolution_clock :: now (); std :: vector < std :: thread > workers ; for ( std :: size_t i = 0 ; i < N / 2 ; ++ i ) { workers . emplace_back ( producer , this , std :: ref ( q )); workers . emplace_back ( consumer , this , std :: ref ( q )); } std :: for_each ( workers . begin (), workers . end (), std :: mem_fn ( & std :: thread :: join )); auto stop = std :: chrono :: high_resolution_clock :: now (); auto duration_ms = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( stop - start ). count (); printf ( \"%s: workers amount = %zu, elapsed time = %lu ms \\n \" , testName . c_str (), workers . size (), duration_ms ); } private : void produce_mutex ( std :: queue < int > & q ) { while ( counter < target ) { if ( q . size () < queue_size_limit ) { std :: lock_guard < std :: mutex > lock ( m ); if ( q . size () < queue_size_limit ) { q . push ( random ()); } } } } void consume_mutex ( std :: queue < int > & q ) { while ( counter < target ) { if ( ! q . empty ()) { std :: lock_guard < std :: mutex > lock ( m ); if ( ! q . empty ()) { q . pop (); counter ++ ; } } } } void produce_cv ( std :: queue < int > & q ) { std :: unique_lock lk ( m ); while ( counter < target ) { cv . wait ( lk , [ & q ]() { return q . size () < queue_size_limit ; }); q . push ( random ()); cv . notify_all (); } } void consume_cv ( std :: queue < int > & q ) { std :: unique_lock lk ( m ); while ( counter < target ) { cv . wait ( lk , [ & q ]() { return ! q . empty (); }); q . pop (); counter ++ ; cv . notify_all (); } } const size_t target = 2'000'000 ; constexpr static size_t queue_size_limit = 100 ; std :: atomic < uint32_t > counter = 0 ; std :: mutex m ; std :: condition_variable cv ; }; int main () { Solution (). run (); return 0 ; }","title":"Producers and consumers"},{"location":"producers_consumers/#producers-and-consumers-problem","text":"","title":"Producers and consumers problem"},{"location":"producers_consumers/#description","text":"There are multiple producers and consumers. Each producer can push item to the queue until queue size limit is reached. Each consumer can pop item from the queue until queue is empty. Accessing queue is not allowed simultaneously: only one producer/consumer can push/pop item at a time.","title":"Description"},{"location":"producers_consumers/#solution-using-mutex","text":"For each push/pop from the queue, lock mutex for exclusive access: void produce_mutex ( std :: queue < int > & q ) { while ( counter < target ) { if ( q . size () < queue_size_limit ) { std :: lock_guard < std :: mutex > lock ( m ); if ( q . size () < queue_size_limit ) { q . push ( random ()); } } } } void consume_mutex ( std :: queue < int > & q ) { while ( counter < target ) { if ( ! q . empty ()) { std :: lock_guard < std :: mutex > lock ( m ); if ( ! q . empty ()) { q . pop (); counter ++ ; } } } } Downside is the huge amount of context switches.","title":"Solution using mutex"},{"location":"producers_consumers/#solution-using-condition-variable","text":"Do push/pop iterations in a loop while is possible. Afterwards notify and unblock other threads. void produce_cv ( std :: queue < int > & q ) { std :: unique_lock lk ( m ); while ( counter < target ) { cv . wait ( lk , [ & q ]() { return q . size () < queue_size_limit ; }); q . push ( random ()); cv . notify_all (); } } void consume_cv ( std :: queue < int > & q ) { std :: unique_lock lk ( m ); while ( counter < target ) { cv . wait ( lk , [ & q ]() { return ! q . empty (); }); q . pop (); counter ++ ; cv . notify_all (); } } Testing results: Running test #1 Mutex : workers amount = 8 , elapsed time = 1260 ms Conditional variable: workers amount = 8 , elapsed time = 435 ms Running test #2 Mutex : workers amount = 8 , elapsed time = 1281 ms Conditional variable: workers amount = 8 , elapsed time = 384 ms Running test #3 Mutex : workers amount = 8 , elapsed time = 1298 ms Conditional variable: workers amount = 8 , elapsed time = 391 ms Running test #4 Mutex : workers amount = 8 , elapsed time = 1321 ms Conditional variable: workers amount = 8 , elapsed time = 397 ms Running test #5 Mutex : workers amount = 8 , elapsed time = 1339 ms Conditional variable: workers amount = 8 , elapsed time = 440 ms Implementation using condition variable gives x3 speed-up due to less amount of context switches. Full source code listing: #include <atomic> #include <chrono> #include <condition_variable> #include <functional> #include <iostream> #include <mutex> #include <queue> #include <ratio> #include <string> #include <thread> class Solution ; typedef void ( Solution ::* ConsumerMemFn )( std :: queue < int > & q ); typedef void ( Solution ::* ProducerMemFn )( std :: queue < int > & q ); class Solution { public : void run () { for ( int t = 0 ; t < 5 ; ++ t ) { printf ( \"Running test #%d \\n \" , t + 1 ); run_test ( \"Mutex \" , & Solution :: produce_mutex , & Solution :: consume_mutex ); run_test ( \"Conditional variable\" , & Solution :: produce_cv , & Solution :: consume_cv ); } } void run_test ( std :: string testName , ProducerMemFn producer , ConsumerMemFn consumer ) { const std :: size_t N = std :: max ( std :: thread :: hardware_concurrency (), 2u ); std :: queue < int > q ; counter = 0 ; auto start = std :: chrono :: high_resolution_clock :: now (); std :: vector < std :: thread > workers ; for ( std :: size_t i = 0 ; i < N / 2 ; ++ i ) { workers . emplace_back ( producer , this , std :: ref ( q )); workers . emplace_back ( consumer , this , std :: ref ( q )); } std :: for_each ( workers . begin (), workers . end (), std :: mem_fn ( & std :: thread :: join )); auto stop = std :: chrono :: high_resolution_clock :: now (); auto duration_ms = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( stop - start ). count (); printf ( \"%s: workers amount = %zu, elapsed time = %lu ms \\n \" , testName . c_str (), workers . size (), duration_ms ); } private : void produce_mutex ( std :: queue < int > & q ) { while ( counter < target ) { if ( q . size () < queue_size_limit ) { std :: lock_guard < std :: mutex > lock ( m ); if ( q . size () < queue_size_limit ) { q . push ( random ()); } } } } void consume_mutex ( std :: queue < int > & q ) { while ( counter < target ) { if ( ! q . empty ()) { std :: lock_guard < std :: mutex > lock ( m ); if ( ! q . empty ()) { q . pop (); counter ++ ; } } } } void produce_cv ( std :: queue < int > & q ) { std :: unique_lock lk ( m ); while ( counter < target ) { cv . wait ( lk , [ & q ]() { return q . size () < queue_size_limit ; }); q . push ( random ()); cv . notify_all (); } } void consume_cv ( std :: queue < int > & q ) { std :: unique_lock lk ( m ); while ( counter < target ) { cv . wait ( lk , [ & q ]() { return ! q . empty (); }); q . pop (); counter ++ ; cv . notify_all (); } } const size_t target = 2'000'000 ; constexpr static size_t queue_size_limit = 100 ; std :: atomic < uint32_t > counter = 0 ; std :: mutex m ; std :: condition_variable cv ; }; int main () { Solution (). run (); return 0 ; }","title":"Solution using condition variable"},{"location":"robots_in_skyscraper/","text":"Robots in skyscraper There are N robots inside skyscraper with F floors. It's possible to select arbitrary set of robots and send a command. A command can be to move one floor up or down and it's execution takes 1 minute. The task is find minimum amount of time to collect all robots on the same floor. Input data The first line contains \\(N\\) - number of robots. Second line contains \\(N\\) integers - number of the corresponding floor, where the \\(i_{th}\\) robot is located. Output data Minimum amount of time in minutes to collect all robots on the same floor. Constraints 1 \\(\\leqslant\\) N \\(\\leqslant\\) \\(10^5\\) \u2014 number of robots 0 \\(\\leqslant\\) F \\(\\leqslant\\) \\(10^9\\) \u2014 number of floors in skyscraper Example test cases Input : 2 4 7 Output : 3 Input : 7 3 1 1 2 10 7 4 Output : 9 Solution If there is one robot or multiple robots at the same floor, then it's needed 0 minutes to collect all robots. If robots are spread on multiple floors, then the fastest way is to collect them in the middle floor. The number of the middle floor is arithmetic mean \\(M\\) for the all given floors. The minimum amount of time to collect robots on \\(M\\) floor then: \\(ans = M - min floor + max floor - M\\) . int main () { int n ; cin >> n ; unsigned long long S = 0 ; int min = INT_MAX ; int max = INT_MIN ; for ( int i = 0 ; i < n ; ++ i ) { int a ; cin >> a ; min = std :: min ( min , a ); max = std :: max ( max , a ); S += a ; } int mid = S / n ; if ( S % n * 2 > n ) { mid ++ ; } unsigned long long ans = mid - min ; ans += max - mid ; cout << ans << endl ; return 0 ; } Solution time complexity: \\(O(n)\\) Solution memory complexity: \\(O(1)\\) References Elephant trainer on algotester","title":"Robots in skyscraper"},{"location":"robots_in_skyscraper/#robots-in-skyscraper","text":"There are N robots inside skyscraper with F floors. It's possible to select arbitrary set of robots and send a command. A command can be to move one floor up or down and it's execution takes 1 minute. The task is find minimum amount of time to collect all robots on the same floor.","title":"Robots in skyscraper"},{"location":"robots_in_skyscraper/#input-data","text":"The first line contains \\(N\\) - number of robots. Second line contains \\(N\\) integers - number of the corresponding floor, where the \\(i_{th}\\) robot is located.","title":"Input data"},{"location":"robots_in_skyscraper/#output-data","text":"Minimum amount of time in minutes to collect all robots on the same floor.","title":"Output data"},{"location":"robots_in_skyscraper/#constraints","text":"1 \\(\\leqslant\\) N \\(\\leqslant\\) \\(10^5\\) \u2014 number of robots 0 \\(\\leqslant\\) F \\(\\leqslant\\) \\(10^9\\) \u2014 number of floors in skyscraper","title":"Constraints"},{"location":"robots_in_skyscraper/#example-test-cases","text":"Input : 2 4 7 Output : 3 Input : 7 3 1 1 2 10 7 4 Output : 9","title":"Example test cases"},{"location":"robots_in_skyscraper/#solution","text":"If there is one robot or multiple robots at the same floor, then it's needed 0 minutes to collect all robots. If robots are spread on multiple floors, then the fastest way is to collect them in the middle floor. The number of the middle floor is arithmetic mean \\(M\\) for the all given floors. The minimum amount of time to collect robots on \\(M\\) floor then: \\(ans = M - min floor + max floor - M\\) . int main () { int n ; cin >> n ; unsigned long long S = 0 ; int min = INT_MAX ; int max = INT_MIN ; for ( int i = 0 ; i < n ; ++ i ) { int a ; cin >> a ; min = std :: min ( min , a ); max = std :: max ( max , a ); S += a ; } int mid = S / n ; if ( S % n * 2 > n ) { mid ++ ; } unsigned long long ans = mid - min ; ans += max - mid ; cout << ans << endl ; return 0 ; } Solution time complexity: \\(O(n)\\) Solution memory complexity: \\(O(1)\\)","title":"Solution"},{"location":"robots_in_skyscraper/#references","text":"Elephant trainer on algotester","title":"References"},{"location":"zero_path/","text":"Problem statement You are given a grid with n rows and m columns. All numbers are equal to 1 or -1. You start from the cell (1,1) and can move one either one cell down or right at a time. Is there a zero path from upper left corner [1,1] to down right corner cell [n,m]? Zero path example Constraints (1 \\(\\leqslant\\) n, m \\(\\leqslant\\) 1000) \u2014 the size of the grid. Observations Zero sum is only possible when path length is even. Path length is equal to \\(n + m - 1\\) . It's enough just to count 1 values, in zero path '1' count is equal to \\(\\frac{(n + m - 1)}{2}\\) . Solution Read grid from stdin; [15-26] For each cell fill a bitset, where \\(i_{th}\\) bit stands for a \\(i\\) sum path from [1,1] to specific cell; If destination cell [n,m] contains a bitset where \\(\\frac{(n + m - 1)}{2}\\) bit is set, then path exists else doesn't. Separate attention deserves line number 33. In this line all possible sums from the left cell b[i][j - 1] and from the up cell b[i - 1][j] are merged to one bitset. If current cell is 1, then all bits are shifted to left, meaning that each sum in the resulting set increased by 1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 int a [ 1001 ][ 1001 ]; bitset < 1001 > b [ 1001 ][ 1001 ]; void solve () { int n , m ; cin >> n >> m ; if (( n + m ) % 2 == 0 ) { cout << \"NO\" << endl ; return ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { b [ i ][ j ]. reset (); cin >> a [ i ][ j ]; if ( a [ i ][ j ] < 0 ) { a [ i ][ j ] = 0 ; } } } b [ 0 ][ 1 ][ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { b [ i ][ j ] = ( b [ i ][ j - 1 ] | b [ i - 1 ][ j ]) << a [ i ][ j ]; } } if ( b [ n ][ m ][( n + m ) / 2 ]) { cout << \"YES\" << endl ; } else { cout << \"NO\" << endl ; } return ; } Solution time complexity: \\(\\frac{O(nm(n+m))}{64}\\) Solution memory complexity: \\(O(nm)\\) References Zero path on codeforces","title":"Zero path"},{"location":"zero_path/#problem-statement","text":"You are given a grid with n rows and m columns. All numbers are equal to 1 or -1. You start from the cell (1,1) and can move one either one cell down or right at a time. Is there a zero path from upper left corner [1,1] to down right corner cell [n,m]?","title":"Problem statement"},{"location":"zero_path/#zero-path-example","text":"","title":"Zero path example"},{"location":"zero_path/#constraints","text":"(1 \\(\\leqslant\\) n, m \\(\\leqslant\\) 1000) \u2014 the size of the grid.","title":"Constraints"},{"location":"zero_path/#observations","text":"Zero sum is only possible when path length is even. Path length is equal to \\(n + m - 1\\) . It's enough just to count 1 values, in zero path '1' count is equal to \\(\\frac{(n + m - 1)}{2}\\) .","title":"Observations"},{"location":"zero_path/#solution","text":"Read grid from stdin; [15-26] For each cell fill a bitset, where \\(i_{th}\\) bit stands for a \\(i\\) sum path from [1,1] to specific cell; If destination cell [n,m] contains a bitset where \\(\\frac{(n + m - 1)}{2}\\) bit is set, then path exists else doesn't. Separate attention deserves line number 33. In this line all possible sums from the left cell b[i][j - 1] and from the up cell b[i - 1][j] are merged to one bitset. If current cell is 1, then all bits are shifted to left, meaning that each sum in the resulting set increased by 1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 int a [ 1001 ][ 1001 ]; bitset < 1001 > b [ 1001 ][ 1001 ]; void solve () { int n , m ; cin >> n >> m ; if (( n + m ) % 2 == 0 ) { cout << \"NO\" << endl ; return ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { b [ i ][ j ]. reset (); cin >> a [ i ][ j ]; if ( a [ i ][ j ] < 0 ) { a [ i ][ j ] = 0 ; } } } b [ 0 ][ 1 ][ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { b [ i ][ j ] = ( b [ i ][ j - 1 ] | b [ i - 1 ][ j ]) << a [ i ][ j ]; } } if ( b [ n ][ m ][( n + m ) / 2 ]) { cout << \"YES\" << endl ; } else { cout << \"NO\" << endl ; } return ; } Solution time complexity: \\(\\frac{O(nm(n+m))}{64}\\) Solution memory complexity: \\(O(nm)\\)","title":"Solution"},{"location":"zero_path/#references","text":"Zero path on codeforces","title":"References"}]}